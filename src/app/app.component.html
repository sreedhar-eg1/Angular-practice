<!-- Rendering component using ngComponentOutlet -->
<!-- <ng-container *ngComponentOutlet="getComponent()">
  <app-admin-profile />
  <app-user-profile />
</ng-container> -->

<hr />

<!-- Instead of using ngComponentOutlet we can use lazy loading -->
<h3>Instead of using ngComponentOutlet we can use lazy loading</h3>
<ng-container *ngComponentOutlet="profileComponent">
  <app-admin-profile />
  <app-user-profile />
</ng-container>

<hr />

<div>
  <h3>Dynamicaaly rendering component using viewcontainerRef</h3>
  <app-host />
</div>

<hr />
<h3>Change detection strategy OnPush and default</h3>
<app-parent />

<hr />
<h3>Different types of applying style</h3>
<app-styles />

<hr />
<div>
  <h3>Two way communication across the component using model</h3>
  <p>Here to achieve this, we must make use of signal</p>
  <app-sizer [(size)]="fontSize" />
  <div>font size in px: {{ fontSize() }}</div>
</div>

<hr />
<div>
  <h3>For loop configuration: $index, $count; $first, $last, $even, $odd</h3>
  @for (item of [1,2,3,4]; track item; let count = $count; let index = $index;
  let first = $first; let last = $last; let even = $even; let odd = $odd) {
  <div>
    <span>Item: {{ item }} &nbsp;</span>
    <span>Index: {{ index }}&nbsp;</span>
    <span>count: {{ count }}&nbsp;</span>
    <span>first: {{ first }}&nbsp;</span>
    <span>last: {{ last }}&nbsp;</span>
    <span>even: {{ even }}&nbsp;</span>
    <span>odd: {{ odd }}&nbsp;</span>
  </div>
  } @empty {
  <div>No items found</div>
  }
</div>

<hr />
<div>
  <h3>Switch Statement</h3>
  @switch (userRole()) { @case ('admin') {
  <div>You are an admin</div>
  } @case ('analyst') {
  <div>You are an analyst</div>
  }@case ('senior analyst') {
  <div>You are an senior analyst</div>
  } @default {
  <div>You are not authorized</div>
  } }
</div>

@let role = userRole(); @let userDetails = num$ | async;

<hr />
<div>
  <h3>Local Template variable</h3>
  <div>Role: {{ role }}</div>
  {{ userDetails | json }}
</div>

<hr />
<div>
  <h3>Default Pipes</h3>
  <div>{{ "Date: " + todaysdate | date : "d, MMMM, Y" }}</div>
  <div>{{ "Uppercase" | uppercase }}</div>
  <div>currency: {{ 1234.567 | currency : "INR" : "code" : "1.2-2" }}</div>
  <div>Number: {{ 1234.567 | number : "1.2-2" }}</div>
  <div>Percentage: {{ 0.1234567 | percent : "1.2-2" }}</div>
  <p>{{ [1, 2, 3, 4, 5, 6] | slice : 1 : 3 }}</p>
  <div>Greeting: {{ "sreedhar" | greet }}</div>
  <div>Exponent of 2, 3: {{ 2 | exponent : 3 }}</div>
  <div>
    To apply pipe to the result of ternary operator [(condition ? a : b) | pipe]
    : because pipe has higher precedence
  </div>
  <div>
    Whenever a value associated with pipe changes, the change detection runs
  </div>
  <div>
    But whenever a value inside object changes then, we need to use impure pipe
  </div>
  <div>impure pipe runs for every DOM event(every keystroke)</div>
  <h4>Impure Pipe</h4>
  <label for="name">My Hero name</label>
  <input
    type="text"
    id="name"
    #inputBox
    (keydown.enter)="onAdd(inputBox.value); inputBox.value = ''"
    placeholder="Enter hero name"
  />
  <p>Hero List</p>
  @for (hero of heros() | flyingHeros; track heros.name) {
  <span>{{ hero.name + "," }}</span>
  }
</div>

<hr />
<div>
  <h3>Template Reference variable</h3>
  <p>
    If we use reference variable inside any if block, it will be limited to that
    block only, we cant use outside the block
  </p>
</div>

<hr />
<div>
  <h3>SVG template in angular</h3>
  <svg>
    <g>
      <rect
        width="100"
        height="100"
        [attr.fill]="fillColor()"
        (click)="onChangeColor()"
      ></rect>
      <text x="110" y="50">Click on rectangle to change color</text>
    </g>
  </svg>
</div>

<hr />
<div>
  <h3>Directive</h3>
  <div>Two Types: Attribute and structural directive</div>
  <h5>Built-in attribute and structural directive</h5>
  <p>Attribute directive : NgClass, NgStyle, NgModel</p>
  <p>Structural directive : NgIf, NgFor, NgSwitch</p>
  <div>
    When there is no element to host directive, then we can use
    <strong>ng-container</strong>
  </div>
  <h3>Custom attribute directive</h3>
  <p appHighlight>Highlight text using custom attribute directive</p>
  <div>To check for event, we need to use hostListener</div>
  <div>We can pass value, and can capture it using input decorator</div>
  <p [appHighlight]="'green'" defaultColor="orange">
    Highlight text using custom attribute directive by passing value
  </p>
  <h3>NgNonBindable</h3>
  <div>
    if we use any expression inside string interpolation it gets executed, if we
    use NgNonBindable, then it wont get executed
  </div>
  <div>Without NgNonBindable: 1 + 1 => {{ 1 + 1 }}</div>
  <div ngNonBindable>With NgNonBindable: {{ 1 + 1 }}</div>
  <h3>Structural directive</h3>
  <div *appHasPermission="'admin'">
    Change template using structural directive(show if it is an admin)
  </div>
  <p>sending single value via input property and adding context</p>
  <div *appDynamicList="users; let user = $user">{{ user.name }}</div>
  <p>sending multiple value via input property and adding multiple context</p>
  <ng-template
    [appDynamicList]="users"
    [otherUsers]="altUsers"
    let-user="$user"
    let-otherUsers="$otherUsers"
  >
    <div>{{ user.name }} | Other Users: {{ otherUsers.length }}</div>
  </ng-template>
</div>

<hr />
<div>
  <h3>Advance structural directive</h3>
  <ng-template appShowIf [isVisible]="isAdmin()">
    <div>Show template if it is true</div>
  </ng-template>
  <button (click)="isAdmin.set(!isAdmin())" type="button">
    Toggle visibility
  </button>
  <ng-template [appRepeatTimes] [count]="5" let-ind="$index">
    <div>Repeat this for a given number of times {{ ind }}</div>
  </ng-template>
</div>

<hr />
<div>
  <h3>NgTemplateGuard</h3>
  <p>
    Directive dont have strict typing, with the help of
    <strong>NgTemplateGaurd</strong> we can enable strict typing
  </p>
  <div *appIsDog="animal()">Show only for dog {{ animal() | json }}</div>
</div>

<hr />
<div>
  <h3>ngTemplateContextGuard</h3>
  <p>
    This is the easy way of sending multiple value: directive name appDemo, if
    we need to send another value give <strong>appDemoUrl</strong> and use
    <strong>url</strong> in the place where you call the directive
  </p>
  <div
    *appDemo="
      demoString();
      url: demoUrl();
      let version = $implicit;
      let name = demo;
      let demoData = url
    "
  >
    This is the context {{ version }} , {{ name }} , {{ demoData | json }}
  </div>
</div>

<hr />
<div>
  <h3>Directive Composition API</h3>
  <p>Will allow us to apply directive to component host elememt</p>
  <p>
    If we have two directive and need to apply for the component, it also can be
    done
  </p>
  <div>
    <app-widget textColor="lightPink" (colorChanged)="changedColor($event)" />
    <p>
      <strong>'app-widget appColor appBackgroundColor/>'</strong> instead of
      using like this (adding multiple directive to component host level) we can
      make use of
      <strong>Directive Composition API</strong>
    </p>
    <p>
      So we dont need to import on each component where we need to use this
      directive, by directly using this directive inside the host componet ts
      file only
    </p>
    <p>That is with the help of <strong>host directive</strong></p>
    <p>
      To send Input values: in the host directive itself, we need to specify
      what and all input value its is holding
    </p>
    <p>We can send output event also</p>
    <p>
      we can also pass alias name for the input and output in the host directive
      itself
    </p>
  </div>
</div>

<hr />
<div>
  <h3>Dependency Injection (DI)</h3>
  <div>
    We need to use injectable decorator to show that services can be injected
  </div>
  <div>Dependency injection can be provided in multiple places</div>
  <strong>Different places</strong>
  <div>Prefered: At application root level</div>
  <div>At the component level</div>
  <div>At the application root level using appConfig</div>
  <div>NgModule based application</div>
  <h5>
    At application root level: Using providedIn: 'root', it will also remove
    unused services from the registry
  </h5>
  <h5>
    At component level, we need to use providers array in the component
    decorator itself and use the service that we need, for each new instance of
    the component new service instance is created. Even if the service is not
    used, then also service will be included
  </h5>
</div>

<hr />
<div>
  <h3>Dependency Techniques(DI): useClass</h3>
  <div>
    <p>Not only services, we can inject boolean, string, date, object... etc</p>
    <p>
      {{ "[{provide: LoggerService, useClass: LoggerService}]" }} here provide
      property will holds the token that serves as a key to consume dependency
      values, second property(here useClass) provider definition object which
      tell injector how to create dependency value
    </p>
    <p>
      <strong>4 types of provider definition object:</strong>useClass,
      useFactory, useExisting, useValue
    </p>
    <h5>UseClass</h5>
    <p>
      provider configuration option, which allows us to replace one dependency
      with anothor on runtime
    </p>
    <p>
      {{
        "providers: [{provide: LoggerService, useClass: ConsoleLoggerService}]"
      }}
      now loggerService has been replaced with ConsoleLoggerService on run time
    </p>
    <p>Here provide should be either a class or a token</p>
    <p>To create injection Token: <strong> {{"const Logger_Token = new InjectionToken\<Logger\>('logger')"}}</strong></p>
  </div>
</div>

<hr>
<div>
  <h3>Dependency Injection Techniques: usefactory</h3>
  <p>useFactory allows us to dynamically create instances of the services or token within our angular application</p>
  <p>Here we need to provide a function to useFactory</p>
  <p>If we want the instance of the service based on condition then we will using useFactory</p>
  <div>
    <app-weather-widget />
  </div>
</div>

<hr>
<div>
  <h3>Dependency Injection Techniques: useValue and useExisting</h3>
  <div>
    <p>If we have two service, and one service need to have the instance of other service then <strong>{{'[{ provide: MainService, useClass: ExperimentService }]'}}</strong></p>
    <p>Here in above with the help of useClass, one instance is replaced to other on run time</p>
    <p>If we want to have same instance for both the services then <strong>useExist</strong> can be used</p>
    <p>If we want to supply any primitive value or object directly, then we can use <strong>useValue</strong></p>
    <p>And also, if we use useValue, then we cant access the method or variable that exist in the service, it will get replaced by the value passed using useValue</p>
    <app-di-widget />
  </div>
</div>

<hr>
<div>
  <h3>Injection Context </h3>
  <div>
    <p>Injection Contect defines the scopes with which dependencies can be injected into a component, services</p>
    <p>When we use useFactory also, we can make use of inject()</p>
  </div>
</div>

<hr>
<div>
  <h3>CanActivateFn with Dependency Injection</h3>
  <div>We can use dependency injection with route guard too</div>
  <router-outlet></router-outlet>
</div>

<hr>
<div>
  <h3>InjectionToken</h3>
  <div> We can configure while using injection token</div>
  <app-injection-widget />
</div>

<hr>
<div>
  <h3>runInInjectionContext & assertInInjectionContext</h3>
  <div>How to inject services outside of the context(other than constructor, inject(), injectionToken, factory)</div>
  <div>If we need to inject any services inside any method then we can use <strong>runInInjectionContext</strong>, it takes two parameter, first is an injector imported as Injector, second a callback function, inside this we need to place our logic</div>
  <div>There is another method which is used to check injection context exist using <strong>assertInInjectionContext</strong>, if injection context doesnot exist then it will throw an error</div>
  <app-injection-widget />
</div>

<hr>
<div>
  <h3>Hierarchical Dependency Injection</h3>
  <div>Two Hierarchy: <strong>EnvironmentInjector</strong> and <strong>ElementInjector</strong></div>
  <h4>EnvironmentInjector</h4>
  <div>It can be configured in two ways</div>
  <div>1. {{'@Injectable()'}} and giving providedIn to root or platform </div>
  <div>2. ApplicationConfig: providers array</div>
  <div>First is is more preffered than the second one, because optimization tool can perform tree shaking and can remove unused dependency</div>
</div>

