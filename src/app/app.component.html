<!-- Rendering component using ngComponentOutlet -->
<!-- <ng-container *ngComponentOutlet="getComponent()">
  <app-admin-profile />
  <app-user-profile />
</ng-container> -->

<hr />

<!-- Instead of using ngComponentOutlet we can use lazy loading -->
<h3>Instead of using ngComponentOutlet we can use lazy loading</h3>
<ng-container *ngComponentOutlet="profileComponent">
  <app-admin-profile />
  <app-user-profile />
</ng-container>

<hr />

<div>
  <h3>Dynamicaaly rendering component using viewcontainerRef</h3>
  <app-host />
</div>

<hr />
<h3>Change detection strategy OnPush and default</h3>
<app-parent />

<hr />
<h3>Different types of applying style</h3>
<app-styles />

<hr />
<div>
  <h3>Two way communication across the component using model</h3>
  <p>Here to achieve this, we must make use of signal</p>
  <app-sizer [(size)]="fontSize" />
  <div>font size in px: {{ fontSize() }}</div>
</div>

<hr />
<div>
  <h3>For loop configuration: $index, $count; $first, $last, $even, $odd</h3>
  @for (item of [1,2,3,4]; track item; let count = $count; let index = $index;
  let first = $first; let last = $last; let even = $even; let odd = $odd) {
  <div>
    <span>Item: {{ item }} &nbsp;</span>
    <span>Index: {{ index }}&nbsp;</span>
    <span>count: {{ count }}&nbsp;</span>
    <span>first: {{ first }}&nbsp;</span>
    <span>last: {{ last }}&nbsp;</span>
    <span>even: {{ even }}&nbsp;</span>
    <span>odd: {{ odd }}&nbsp;</span>
  </div>
  } @empty {
  <div>No items found</div>
  }
</div>

<hr />
<div>
  <h3>Switch Statement</h3>
  @switch (userRole()) { @case ('admin') {
  <div>You are an admin</div>
  } @case ('analyst') {
  <div>You are an analyst</div>
  }@case ('senior analyst') {
  <div>You are an senior analyst</div>
  } @default {
  <div>You are not authorized</div>
  } }
</div>

@let role = userRole(); @let userDetails = num$ | async;

<hr />
<div>
  <h3>Local Template variable</h3>
  <div>Role: {{ role }}</div>
  {{ userDetails | json }}
</div>

<hr />
<div>
  <h3>Default Pipes</h3>
  <div>{{ "Date: " + todaysdate | date : "d, MMMM, Y" }}</div>
  <div>{{ "Uppercase" | uppercase }}</div>
  <div>currency: {{ 1234.567 | currency : "INR" : "code" : "1.2-2" }}</div>
  <div>Number: {{ 1234.567 | number : "1.2-2" }}</div>
  <div>Percentage: {{ 0.1234567 | percent : "1.2-2" }}</div>
  <p>{{ [1, 2, 3, 4, 5, 6] | slice : 1 : 3 }}</p>
  <div>Greeting: {{ "sreedhar" | greet }}</div>
  <div>Exponent of 2, 3: {{ 2 | exponent : 3 }}</div>
  <div>
    To apply pipe to the result of ternary operator [(condition ? a : b) | pipe]
    : because pipe has higher precedence
  </div>
  <div>
    Whenever a value associated with pipe changes, the change detection runs
  </div>
  <div>
    But whenever a value inside object changes then, we need to use impure pipe
  </div>
  <div>impure pipe runs for every DOM event(every keystroke)</div>
  <h4>Impure Pipe</h4>
  <label for="name">My Hero name</label>
  <input
    type="text"
    id="name"
    #inputBox
    (keydown.enter)="onAdd(inputBox.value); inputBox.value = ''"
    placeholder="Enter hero name"
  />
  <p>Hero List</p>
  @for (hero of heros() | flyingHeros; track heros.name) {
  <span>{{ hero.name + "," }}</span>
  }
</div>

<hr />
<div>
  <h3>Template Reference variable</h3>
  <p>
    If we use reference variable inside any if block, it will be limited to that
    block only, we cant use outside the block
  </p>
</div>

<hr />
<div>
  <h3>SVG template in angular</h3>
  <svg>
    <g>
      <rect
        width="100"
        height="100"
        [attr.fill]="fillColor()"
        (click)="onChangeColor()"
      ></rect>
      <text x="110" y="50">Click on rectangle to change color</text>
    </g>
  </svg>
</div>

<hr />
<div>
  <h3>Directive</h3>
  <div>Two Types: Attribute and structural directive</div>
  <h5>Built-in attribute and structural directive</h5>
  <p>Attribute directive : NgClass, NgStyle, NgModel</p>
  <p>Structural directive : NgIf, NgFor, NgSwitch</p>
  <div>
    When there is no element to host directive, then we can use
    <strong>ng-container</strong>
  </div>
  <h3>Custom attribute directive</h3>
  <p appHighlight>Highlight text using custom attribute directive</p>
  <div>To check for event, we need to use hostListener</div>
  <div>We can pass value, and can capture it using input decorator</div>
  <p [appHighlight]="'green'" defaultColor="orange">
    Highlight text using custom attribute directive by passing value
  </p>
  <h3>NgNonBindable</h3>
  <div>
    if we use any expression inside string interpolation it gets executed, if we
    use NgNonBindable, then it wont get executed
  </div>
  <div>Without NgNonBindable: 1 + 1 => {{ 1 + 1 }}</div>
  <div ngNonBindable>With NgNonBindable: {{ 1 + 1 }}</div>
  <h3>Structural directive</h3>
  <div *appHasPermission="'admin'">
    Change template using structural directive(show if it is an admin)
  </div>
  <p>sending single value via input property and adding context</p>
  <div *appDynamicList="users; let user = $user">{{ user.name }}</div>
  <p>sending multiple value via input property and adding multiple context</p>
  <ng-template
    [appDynamicList]="users"
    [otherUsers]="altUsers"
    let-user="$user"
    let-otherUsers="$otherUsers"
  >
    <div>{{ user.name }} | Other Users: {{ otherUsers.length }}</div>
  </ng-template>
</div>

<hr />
<div>
  <h3>Advance structural directive</h3>
  <ng-template appShowIf [isVisible]="isAdmin()">
    <div>Show template if it is true</div>
  </ng-template>
  <button (click)="isAdmin.set(!isAdmin())" type="button">
    Toggle visibility
  </button>
  <ng-template [appRepeatTimes] [count]="5" let-ind="$index">
    <div>Repeat this for a given number of times {{ ind }}</div>
  </ng-template>
</div>

<hr />
<div>
  <h3>NgTemplateGuard</h3>
  <p>
    Directive dont have strict typing, with the help of
    <strong>NgTemplateGaurd</strong> we can enable strict typing
  </p>
  <div *appIsDog="animal()">Show only for dog {{ animal() | json }}</div>
</div>

<hr />
<div>
  <h3>ngTemplateContextGuard</h3>
  <p>
    This is the easy way of sending multiple value: directive name appDemo, if
    we need to send another value give <strong>appDemoUrl</strong> and use
    <strong>url</strong> in the place where you call the directive
  </p>
  <div
    *appDemo="
      demoString();
      url: demoUrl();
      let version = $implicit;
      let name = demo;
      let demoData = url
    "
  >
    This is the context {{ version }} , {{ name }} , {{ demoData | json }}
  </div>
</div>

<hr />
<div>
  <h3>Directive Composition API</h3>
  <p>Will allow us to apply directive to component host elememt</p>
  <p>
    If we have two directive and need to apply for the component, it also can be
    done
  </p>
  <div>
    <app-widget textColor="lightPink" (colorChanged)="changedColor($event)" />
    <p>
      <strong>'app-widget appColor appBackgroundColor/>'</strong> instead of
      using like this (adding multiple directive to component host level) we can
      make use of
      <strong>Directive Composition API</strong>
    </p>
    <p>
      So we dont need to import on each component where we need to use this
      directive, by directly using this directive inside the host componet ts
      file only
    </p>
    <p>That is with the help of <strong>host directive</strong></p>
    <p>
      To send Input values: in the host directive itself, we need to specify
      what and all input value its is holding
    </p>
    <p>We can send output event also</p>
    <p>
      we can also pass alias name for the input and output in the host directive
      itself
    </p>
  </div>
</div>

<hr />
<div>
  <h3>Dependency Injection (DI)</h3>
  <div>
    We need to use injectable decorator to show that services can be injected
  </div>
  <div>Dependency injection can be provided in multiple places</div>
  <strong>Different places</strong>
  <div>Prefered: At application root level</div>
  <div>At the component level</div>
  <div>At the application root level using appConfig</div>
  <div>NgModule based application</div>
  <h5>
    At application root level: Using providedIn: 'root', it will also remove
    unused services from the registry
  </h5>
  <h5>
    At component level, we need to use providers array in the component
    decorator itself and use the service that we need, for each new instance of
    the component new service instance is created. Even if the service is not
    used, then also service will be included
  </h5>
</div>

<hr />
<div>
  <h3>Dependency Techniques(DI): useClass</h3>
  <div>
    <p>Not only services, we can inject boolean, string, date, object... etc</p>
    <p>
      {{ "[{provide: LoggerService, useClass: LoggerService}]" }} here provide
      property will holds the token that serves as a key to consume dependency
      values, second property(here useClass) provider definition object which
      tell injector how to create dependency value
    </p>
    <p>
      <strong>4 types of provider definition object:</strong>useClass,
      useFactory, useExisting, useValue
    </p>
    <h5>UseClass</h5>
    <p>
      provider configuration option, which allows us to replace one dependency
      with anothor on runtime
    </p>
    <p>
      {{
        "providers: [{provide: LoggerService, useClass: ConsoleLoggerService}]"
      }}
      now loggerService has been replaced with ConsoleLoggerService on run time
    </p>
    <p>Here provide should be either a class or a token</p>
    <p>To create injection Token: <strong> {{"const Logger_Token = new InjectionToken\<Logger\>('logger')"}}</strong></p>
  </div>
</div>

<hr>
<div>
  <h3>Dependency Injection Techniques: usefactory</h3>
  <p>useFactory allows us to dynamically create instances of the services or token within our angular application</p>
  <p>Here we need to provide a function to useFactory</p>
  <p>If we want the instance of the service based on condition then we will using useFactory</p>
  <div>
    <app-weather-widget />
  </div>
</div>

<hr>
<div>
  <h3>Dependency Injection Techniques: useValue and useExisting</h3>
  <div>
    <p>If we have two service, and one service need to have the instance of other service then <strong>{{'[{ provide: MainService, useClass: ExperimentService }]'}}</strong></p>
    <p>Here in above with the help of useClass, one instance is replaced to other on run time</p>
    <p>If we want to have same instance for both the services then <strong>useExist</strong> can be used</p>
    <p>If we want to supply any primitive value or object directly, then we can use <strong>useValue</strong></p>
    <p>And also, if we use useValue, then we cant access the method or variable that exist in the service, it will get replaced by the value passed using useValue</p>
    <app-di-widget />
  </div>
</div>

<hr>
<div>
  <h3>Injection Context </h3>
  <div>
    <p>Injection Contect defines the scopes with which dependencies can be injected into a component, services</p>
    <p>When we use useFactory also, we can make use of inject()</p>
  </div>
</div>

<hr>
<div>
  <h3>CanActivateFn with Dependency Injection</h3>
  <div>We can use dependency injection with route guard too</div>
  <router-outlet></router-outlet>
</div>

<hr>
<div>
  <h3>InjectionToken</h3>
  <div> We can configure while using injection token</div>
  <app-injection-widget />
</div>

<hr>
<div>
  <h3>runInInjectionContext & assertInInjectionContext</h3>
  <div>How to inject services outside of the context(other than constructor, inject(), injectionToken, factory)</div>
  <div>If we need to inject any services inside any method then we can use <strong>runInInjectionContext</strong>, it takes two parameter, first is an injector imported as Injector, second a callback function, inside this we need to place our logic</div>
  <div>There is another method which is used to check injection context exist using <strong>assertInInjectionContext</strong>, if injection context doesnot exist then it will throw an error</div>
  <app-injection-widget />
</div>

<hr>
<div>
  <h3>Hierarchical Dependency Injection</h3>
  <div>Two Hierarchy: <strong>EnvironmentInjector</strong> and <strong>ElementInjector</strong></div>
  <h4>EnvironmentInjector</h4>
  <div>It can be configured in two ways</div>
  <div>1. {{'@Injectable()'}} and giving providedIn to root or platform </div>
  <div>2. ApplicationConfig: providers array</div>
  <div>First is is more preffered than the second one, because optimization tool can perform tree shaking and can remove unused dependency</div>
</div>

<hr>
<div>
  <h3>Override Root Providers with bootstrapApplication</h3>
  <h4>ModuleInjector</h4>
  <div>In NgModule based application, ModuleInjector can be configured in one of the two ways</div>
  <div>1. {{'@Injectable()'}} and giving providedIn to root or platform </div>
  <div>2. {{'@NgModule()'}}: providers array</div>
  <div><strong>Platform Injector</strong> There are two more injector above the root, an additional EnvironmentInjector and NullInjector()</div>
  <div>Hierarchy : Null Injector -> EnvironmentInjector -> root EnvironmentInjector </div>
  <div>If we are looking at null injector, it always throws an error unless we have use {{'@optional()'}}</div>
</div>

<hr>
<div>
  <h3>ElementInjectors </h3>
  <div><strong>Implicit Creation</strong> : For each DOM element like a componet app-child app-root... a element injectors has been created automatically</div>
  <div>Which means each component, directive, template.. has its own associated element injector</div>
  <div><strong>Hierarchy structure</strong> : heirarchy is based on DOM heirarchy</div>
  <div>providing services in <strong>{{'@Component()'}}</strong> decorator:</div>
  <div>We can see two providers in {{'@Component()'}}: <strong>providers</strong> and <strong>viewProviders</strong></div>
  <div>When we provide a service in <strong>providers</strong> or <strong>viewProviders</strong> we are telling angular to create the instance of the service and also associate with its componet element injector</div>
  <div>So if we create a service, then that service will be associated with its components element injector and also child components element injector</div>
  <div>When component instance is destroyed, service instance also destroyed as service as associated with components element injector</div>
</div>

<hr>
<div>
  <h3>ElementInjector & EnvironmentInjector</h3>
  <div>
    <h4>Providers and Element Injector:</h4>
    <div>When we use provider property in component or directive, then it will be associated with element injector</div>
    <div>Component or directive that are present on the same element share the same element injector</div>
    <div><strong>EnvironmentInjector </strong> : If no provider found in element hierarchy, then it move into EnvironmentInjector, This EnvironmentInjector is shared by all components in the application(application wide provider)</div>
    <div><strong>NullInjector </strong> : If no provider in EnvironmentInjector then it throws an error</div>
  </div>
</div>

<hr>
<div>
  <h3>Dependency Injection with {{'@Self and @Optional'}}</h3>
  <div>
    <div>If angular doesnot find the service that we are looking for {{'@Optional()'}}</div>
    <div>Where to start looking {{'@SkipSelf()'}}</div>
    <div>Where to stop looking {{'@Self()'}} and {{'@host()'}}</div>
    <div>Angular resolution behavior can be modified using above methods</div>
    <h4>{{'@Optional()'}}</h4>
    <div>Indicates that injected service is optional, if it not resolved at runtime, return null instead of throwing an error</div>
    <h4>{{'@Self()'}}</h4>
    <div>Limit the search of the service to the current ElementInjector, means it doesnot trace up to find the services</div>
    <h4>{{'@SkipSelf()'}}</h4>
    <div>Start the search from the parent ElementInjector by skipping the current ElementInjector</div>
    <h4>{{'@host()'}}</h4>
    <div>Designate the current component as the last stop in the injection tree when searching for services in the providers(look at the host element injector)</div>
    <div>We can use any of the method together, accept ({{'@Self()'}} and {{'@host()'}}) and ({{'@SkipSelf()'}} and {{'@Self()'}}) </div>
    <div>When we are using host while using dependency injection, then we cant provide service in providers array, we should provide it in viewproviders array</div>
    <h4>Poviders and viewProviders</h4>
    <div>providers: when the service provided is a child of parent component, then ehile using host dependency injection works(Its like ng-content data) otherwise we need to use viewProviders to make it work</div>
  </div>
  <div>
    <app-di-parent />
  </div>
</div>

<hr>
<div>
  <h3>Providers vs ViewProviders</h3>
  <div>
    <app-di-provider-view-provider />
    <div>logical things happened here</div>
    <pre ngNonBindable>&#123;&#123;
      '&lt;app-root &#64;ApplicationConfig
        &#64;Inject(FlowerService) flower=&quot;üå∫&quot;&gt;
        &lt;#VIEW&gt;
          &lt;p&gt;Emoji from FlowerService: &#123;&#123;flower.emoji&#125;&#125; (üå∫)&lt;/p&gt;
          &lt;app-child &#64;Provide(FlowerService=&quot;üåª&quot;)
                    &#64;Inject(FlowerService)=&gt;&quot;üåª&quot;&gt; &lt;!-- search ends here --&gt;
            &lt;#VIEW&gt; &lt;!-- search starts here --&gt;
              &lt;h2&gt;Child Component&lt;/h2&gt;
              &lt;p&gt;Emoji from FlowerService: &#123;&#123;flower.emoji&#125;&#125; (üåª)&lt;/p&gt;
            &lt;/#VIEW&gt;
          &lt;/app-child&gt;
        &lt;/#VIEW&gt;
      &lt;/app-root&gt;'
      &#125;&#125;</pre>
  </div>
  <div>Using view provider, dependency injection happens inside view</div>
  <div>Logical thing happened while using viewProvider </div>
  <pre ngNonBindable>
    &lt;app-root &#64;ApplicationConfig<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&#64;Inject(AnimalService) animal=&gt;&quot;üê≥&quot;&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;#VIEW&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;app-child&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;#VIEW &#64;Provide(AnimalService=&quot;üê∂&quot;)<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#64;Inject(AnimalService=&gt;&quot;üê∂&quot;)&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- ^^using viewProviders means AnimalService is available in &lt;#VIEW&gt; --&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;Emoji from AnimalService: &#123;&#123;animal.emoji&#125;&#125; (üê∂)&lt;/p&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/#VIEW&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/app-child&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;/#VIEW&gt;<br />
    &lt;/app-root&gt;
  </pre>
  <div>view providers is similar to providers, with one difference that is configured providers in viewProviders are not visible to the projected content(Ng Content) </div>
  <h4>Final logic: View provider check dependency injection from view</h4>
  <pre ngNonBindable>
    &lt;app-root &#64;ApplicationConfig<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&#64;Inject(AnimalService) animal=&gt;&quot;üê≥&quot;&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;#VIEW&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;app-child&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;#VIEW &#64;Provide(AnimalService=&quot;üê∂&quot;)<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#64;Inject(AnimalService=&gt;&quot;üê∂&quot;)&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- ^^using viewProviders means AnimalService is available in &lt;#VIEW&gt; --&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;Emoji from AnimalService: &#123;&#123;animal.emoji&#125;&#125; (üê∂)&lt;/p&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div class=&quot;container&quot;&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h3&gt;Content projection&lt;/h3&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;app-inspector &#64;Inject(AnimalService) animal=&gt;&quot;üê≥&quot;&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;Emoji from AnimalService: &#123;&#123;animal.emoji&#125;&#125; (üê≥)&lt;/p&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/app-inspector&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;app-inspector&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;#VIEW &#64;Inject(AnimalService) animal=&gt;&quot;üê∂&quot;&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;Emoji from AnimalService: &#123;&#123;animal.emoji&#125;&#125; (üê∂)&lt;/p&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/#VIEW&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/app-inspector&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/#VIEW&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/app-child&gt;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&lt;/#VIEW&gt;<br />
    &lt;/app-root&gt;
  </pre>
</div>

<hr>
<div>
  <h3>Service Isolation in Angular Standalone Components</h3>
  <div>
    <app-villian-list />
    <div><strong>Root App Component</strong></div>
    @for (villan of villans(); track villan) {
      <div>{{villan}}</div>
  }
  <button (click)="onAddVillan()" type="button">Add Villan</button>
  </div>
  <div>Here the service that injected in app and villianList component instance is not same(both have different instances)</div>
  <div>When we try to add villan only one component gets updated, which says both component services have different instances, when we not provide services in root</div>
</div>

<hr>
<div>
  <h3>Isolate Services for Multiple Edit Sessions</h3>
  <div>
    <h4>Hero Tax Returns</h4>
    @for (heroTaxReturn of heroTaxReturns; track heroTaxReturn.id) {
      <app-hero-tax [taxReturn]="heroTaxReturn"></app-hero-tax>
    }
  </div>
  <div>
    <h4>Specialized Providers in Standalone Components</h4>
    <p>When parent component provides one service, where in child component need some other service, then we need to use Specialized Providers</p>
    <div>
      <app-car></app-car>
      <app-sports-car></app-sports-car>
    </div>
  </div>
</div>

<hr>
<div>
  <h3>Angular Tree shaking</h3>
  <div>
    <p>Optimizing the bundle size for application using lightwight injection token</p>
    <h5>Optimizing the application via tree shaking</h5>
    <p>It remove unused code from the final bundle of the client application</p>
    <p>To make proper use of tree shaking, we need to apply injection token in particular manner</p>
    <p><strong>Token: </strong> It is used to look up a dependency in the dependency injection system</p>
    <p>Two scenario, which cause token to be retained, preventing tree shaking</p>
    <p>1. While using content queries  (contentChild or contentChildren)</p>
    <p>2. In constructor injection, where a class is injected using dependency injection</p>
    <p><strong>Solution:</strong> Need to use kightweight injection token</p>
  </div>
  <div>
    <app-lib-card>
      <!-- comment and uncomment to see tree shacking -->
      <!-- <app-lib-header></app-lib-header> -->
    </app-lib-card>
  </div>
  <h4>Tree-Shaking and Lightweight Injection Tokens</h4>
  <div>
    <p>To avoid retaining of unneccessary unneccessary token and component in the final bundle, lightweight injection token are used </p>
    <p>By creating abstract class and extending it in our component(injected in constructor or while using content queries)</p>
  </div>
</div>

<hr>
<div>
  <h3>Dependency Injection with Custom Providers</h3>
  <div>
    <p>Token that angular can use to inject a specific value or dependency, its expecially usefull when we want to inject other than class or a service(like localstorage)</p>
    <p>a factory function is used to return a value or object that should be injected for the token, in this case localStorage object</p>
    <p>{{'@Inject decorator'}} allows you to specify  exactly what token should be injected into the constructor of the class</p>
    <p>Detail implementation is in browser storage service</p>
  </div>
</div>

<hr>
<div>
  <h3>Direct DOM access using elementRef</h3>
  <div>
    <p>A class provided by angular which gives access to the native DOM element of a component or directive</p>
    <p>We can use renderer2 over ekementRef</p>
  </div>
</div>

<hr>
<div>
  <h3>prevent Circular dependency using forwardRef</h3>
  <div>
    <p>when two or more classes depend on each other directly or indirectly, creating a situaltion where angular cannot resolve the dependency</p>
    <p>forwardRef is a way to solve this problem, which breaks circular dependency</p>
    <p>It does this by allowing a class to refer to the another class indirectly</p>
    <p>Here forwardRef delays the evaluation of a dependency</p>
  </div>
  <div>
    <app-list></app-list>
  </div>
</div>

<hr>
<div>
  <h3>Signals</h3>
  <div>
    <p>Two types of signals: <strong>Writable signals</strong> and <strong>Read only signal</strong></p>
    <p><strong>Writable Signals:</strong> This can be updated, meaning we can both read and modify values</p>
    <p><strong>Read only signals:</strong> This only allow reading the value, but cannit modify</p>
  </div>
  <hr>
  <h4>Computed signals</h4>
  <div>
    <p>Its a way to derive value from other signals and also track dependencies between the signals</p>
    <p>Its a read only signal which derive value from other signals</p>
    <p>We must use computed() method and pass a function to use this</p>
    <p>whenever value in signal changes, computed automatically runs and derive values based on that</p>
    <p>we can also perform lazy evaluation and memoization</p>
    <p><strong>Lazy evaluation:</strong>  angular does not compute their values until you actually read them</p>
    <p><strong>Memoization:</strong> Which means they cache calculated values, means untill the signal gets changed, we get the old computed cached value</p>
    <p>If computed signal depend on two or more signal, then if any one of them changes, then this computed block gets executed</p>
    <div>
      <app-computed-signal (sendEmittedCounter)="getCounter($event)" #computedSignal></app-computed-signal>
    </div>
  </div>
  <hr>
  <h4>Effects in signal</h4>
  <div>
    <p>effects allow us to trigger side effects when one or more signal changes, and they serve as an important tool for integrating signals into different part of an application</p>
    <p>Effect is an function, which runs whenever a signal changes</p>
    <p>When we create effect using effect(), angular tracks the signals used within the effect and re run the function when any one of the signal changes</p>
    <p>first time execution will be there, so even though no signal changes, effects always execute first time</p>
    <p>effect execute asynchronously during angular change detection process, and also effect re executes when angular finishes processing changes in the application state</p>
    <p>Whenever we are using multiple signal inside effects which leads to error, then we ineed to use allowSignalWrites to true (Not Required on angular 19 and above)</p>
  </div>
  <hr>
  <h4>Create and destroy effects</h4>
  <div>
    <p>Signals aloows for reactive data flow, with effects you can respond to changes in signal values</p>
    <p>To create effect, it must be done within injection context</p>
    <p>Creating effect in a component constructor</p>
    <p>We can create effects by creating a variable and assigning effects to it</p>
    <p>We can also create effect outside the constructor,</p>
    <p>By default angular destroys the effect, when component or dervices are destroyed, we can also manully destroy the effect by providing <strong>manualCleanup</strong> to true, and manually destroying it in ngDestroy</p>
  </div>
  <hr>
  <h4>Equality Functions in Angular Signals</h4>
  <div>
    <p>whenever we compare two signals, resul yields false, because two signals are different instances</p>
    <p>To compare deeply we can use third party package such as loadash and set {{'{equal: isEqual}'}} as a second parameter to the siganl, here isEqual is imported from loadAsh which deep compare </p>
  </div>
  <hr>
  <h4> Read Without Tracking Dependencies</h4>
  <div>
    <p>While using computed or effects, its crucial to control which signal read are tracked as dependencies</p>
    <p><strong>Untracked function: </strong> allows you to read a signal without marking it as a dependency of the current reactive context</p>
    <p>this is beneficial when we dont want to react to certain signals changes</p>
    <p><strong>untracked(inside this method we can pass signal that need to be untracked)</strong></p>
  </div>
  <hr>
  <h4>Cleanup in effects</h4>
  <div>
    <p>When we use effect its better to cleanup to avoid memory leaks, it can be achieved by passing cleanup function</p>
    <p><strong>Cleanup function: </strong>Where we can write cleanup logic, which will be executed before effect run again or effect that will be destroyed</p>
  </div>
  <hr>
  <h4>Rxjs Interop package</h4>
  <div>
    <p><strong>toSignal() method: </strong>Will convert rxjx observable to angular signals, toSignal automatically subscribe to the observable and update the siganl value as the observable emit new values</p>
    <p>We can pass initialValue as an option(object, second parameter) to give it a initial value</p>
    <p> by default by using toSignal gets destroyed when component gets destroyed, we can manually destroy using manualCleanup</p>
    <p>If an observable throws an error, then we can use try catch to catch the error</p>
    <p><strong>toObservable in Angular :</strong> which convert reactive signals into an observable</p>
    <p>when a signal value changes, toObservable utility track the changes using the effects and emits the updated value through an observable</p>
    <p><strong>outputFromObservable : </strong> If we have observable in child component, and whenever this observable emits data we need to send it as a event to parent component</p>
    <p>We can achieve this using a method called outputFromObservable</p>
    <p><strong>outputToObservable : </strong>The emitted value that was recieved in parent component can be converted into observable using outputToObservable</p>
    <span>Converted to observable where the value is sent from child component using <strong>outputToObservable : </strong> {{ convertCounterToObservable$ | async }}</span>
  </div>
</div>

<hr>
<h3>Signal Input</h3>
<div>
  <p>Which allow component value to be bound to the parent componet</p>
  <p>We can make use of <strong>computed</strong> and <strong>effect</strong> along with input signal</p>
  <p>We can also transform raw value which are comming from parent component using input signal</p>
  <app-input-signals [userRole]="userRole()" [(isChecked)]="checked" (isCheckedChange)="getChangeValue($event)"/>
</div>

<hr>
<div>
  <h3>Model Input</h3>
  <div>
    <p>Which allow two way data binding within the component</p>
    <p>When we use model, and the model name is isChecked, and we can recieve the changes in parent componet bu appending change to the end, here for isChe</p>
    <div>Component level two way binding : {{checked()}}</div>
  </div>
</div>

<hr>
<div>
  <h3>View Child and View Children</h3>
  <div>
    <p>Angular provide two types of queries</p>
    <p><strong>View Queries :</strong> This retrieve results from the components own template</p>
    <p><strong>Content Queries :</strong>This retrieve results from the content projected into the template</p>
    <p><strong>View Child :</strong>Querying the single element or the component. retrieves single element either by a string reference (template variable) or by the component or template type<p>
    <p #element>Get this element using viewchild</p>
    <p #element>Get this element using viewchilden (Multiple element)</p>
    <P>we can use signal based viewChild with computed as well as effect</P>
    <p>We can pass the read type, i.e reading the elememt with particular type by passing read as an second parameter inside object and specifying the type</p>
  </div>
</div>

<hr>
<div>
  <h3>Content Queries: contentChild & contentChildren</h3>
  <div>
    <p>Allow a component to access child elements that are projected into its content from a parent component</p>
    <app-content>
      <h5 #h5>This is the header projected from parent component</h5>
      <h5 #h5>This is the header projected from parent component to access multiple using contentChilden </h5>
      <p>By default queries return only the direct children, to get the descendent we need to pass some options, i.e by passing descendent to true, for component, we dont need to pass this option</p>
      <app-content-projection></app-content-projection>
    </app-content>
  </div>
</div>

<hr>
<h3>No More Undefined Values in Your Components</h3>
<div>
  <p>When angular builds a component, there is a period where signal query has been created, but template has not been fully processed, during this time query will return undefined for single query and empty array for multiple query</p>
  <p><strong>Query declaration and usage : </strong> we can only declare signal based queries in class class properties, These functions should not be called in other parts of the component(e,g in constructor)</p>
</div>

